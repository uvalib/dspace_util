# src/dspace_structure.rb
#
# frozen_string_literal: true
# warn_indent:           true
#
# Accept XML and generate output for tmp/saved/*/structure.txt.

require 'common'
require 'logging'
require 'base_options'

require 'nokogiri'

# =============================================================================
# :section: Class
# =============================================================================

# Options applicable to the dspace_structure application.
#
class Options < BaseOptions

  # ===========================================================================
  # :section: Properties
  # ===========================================================================

  attr_accessor :deployment

  # ===========================================================================
  # :section: BaseOptions overrides
  # ===========================================================================

  protected

  # Create an option parser for the option attributes of this class.
  #
  # @return [OptionParser]
  #
  def new_parser(&blk)
    super do |p|
      p.on('--deployment NAME', 'Target deployment') { @deployment = _1 }
      blk&.call(p)
    end
  end

  # Resolve option attributes after parsing.
  #
  # @return [void]
  #
  def finalize_options
    super
    case @deployment
      when nil       then @deployment = DEPLOYMENT
      when /^prod.*/ then @deployment = 'production'
      when /^stag.*/ then @deployment = 'staging'
      when /^dev.*/  then @deployment = 'development'
    end
  end

  # Display final option settings for diagnostics.
  #
  # @return [void]
  #
  def show_help_debug
    super
    output_line "HELP: deployment    = #{deployment.inspect}"
  end

end

# =============================================================================
# :section: Methods
# =============================================================================

public

def option = Options.instance

# Generate an output table for tmp/saved/*/structure.txt.
#
# @param [String, IO, nil] file       File source or $stdin if empty.
# @param [Hash]            opt        Passed to #generate_structure_txt.
#
# @return [Boolean]                   False if errors prevented output.
#
def output_collections(file = nil, **opt)
  pairs = parse_structure_xml(file)
  text  = pairs && generate_structure_txt(pairs, **opt)
  good  = text.present?
  puts text if good
  good
end

# Extract Collections from the output of `dspace structure-builder`.
#
# @param [String, IO, nil] file       File source or $stdin if empty.
#
# @return [Hash{String=>String}]      Handle mapped to Collection name.
# @return [nil]                       If there were XML parse errors.
#
def parse_structure_xml(file = nil)
  # Parse the XML file.
  if file.is_a?(String)
    # noinspection RubyMismatchedArgumentType
    doc = File.open(file) { Nokogiri::XML(_1) }
  else
    doc = Nokogiri::XML(file || $stdin)
  end
  if doc.errors.present?
    doc.errors.each do |err|
      error err
    end
    return
  end

  # Extract Collection handle/name pairs.
  pairs = []
  doc.xpath('//community').each do |community|
    comm = community.xpath('name').text
    community.xpath('collection').each do |collection|
      name   = collection.xpath('name').text
      handle = collection['identifier']
      if handle.present?
        pairs << [handle, name]
      else
        warning "no handle identifier for #{comm.inspect} >> #{name.inspect}"
      end
    end
  end
  pairs.to_h
end

# Generate the output to place into tmp/saved/*/structure.txt.
#
# @param [Hash{String=>String}] pairs
# @param [String, nil] target         Target deployment (option.deployment).
# @param [String, nil] program        Generator name for output comment.
#
# @return [String]
#
def generate_structure_txt(pairs, target: nil, program: nil, **)
  target  = option.deployment if target.nil?
  program = File.basename($0) if program.nil?

  hdl_header  = '# HANDLE'
  name_header = 'COLLECTION NAME'

  width  = [hdl_header, *pairs.keys].map(&:size).max
  result = [
    "# tmp/saved/#{target}/structure.txt",
    '#',
    '# Publication collections required to receive imports.',
    "# Generated by #{program}",
    '',
    '%-*s # %s' % [width, hdl_header, name_header],
  ]
  pairs.each do |hdl, name|
    name = "  #{name}" unless name.start_with?('~')
    result << '%-*s | %s' % [width, hdl, name]
  end
  result.join("\n")
end

# =============================================================================
# :section: Main program.
# =============================================================================

if $0 == __FILE__
  output_collections(option.args.first) or exit(false)
end
