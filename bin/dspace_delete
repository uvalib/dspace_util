#! /bin/bash
#
# Remove items from DSpace.
#
# Usage: dspace_delete [DEPLOYMENT] [OPTIONS] ITEM...
# Usage: dspace_delete [DEPLOYMENT] --all
#
# OPTIONS
#   --all           All items from collections listed in data/collection.txt.
#   --handle        Next is a handle or list of handles.
#   --mapfile       Next is a mapfile or newline-delimited list of mapfiles.
#   --collection    Next is a collection or list of collections.
#   --foreground    Do not run in the background with "nohup".
#
# Each ITEM may be:
#
# * An item handle or list of item handles.
#   Item handles may be either be in the two column format expected by DSpace
#   where the second column is a handle, or simple lists of handles one per
#   line.
#
# * A mapfile or newline-delimited list of mapfiles.
#   Mapfiles may be either be in the two column format expected by DSpace where
#   the second column is a handle, or simple lists of handles one per line.
#
# * A collection or list of collections.
#   Collections can be specified by handle (or as a file containing handles)
#   but only after a --collection flag; plain arguments which are handles will
#   always be interpreted as items.
#   Collections are emptied but not removed.
#
# To ensure that network disconnection does not cause long-running imports to
# fail, the remote shell is run with "nohup" by default.
#
# Note that, because this script requires support on the DSpace host side,
# it will run `dspace_update_home` for you in order to ensure that the remote
# side is up-to-date.

PROGRAM=`realpath "$0"`
BIN_DIR=`dirname "$PROGRAM"`
PRJ_DIR=`dirname "$BIN_DIR"`

source "$BIN_DIR/dspace_values"

NOHUP='true'    # Background the delete process.
WAIT='true'     # Wait for background delete process to finish.
HELP=''         # Display help only.
ALL=''          # All items from collections in data/collection.txt

NAMES=()        # Arguments to be interpreted for handles of items to delete.
HANDLES=()      # Handles of items to delete.
MAP_FILES=()    # Source mapfile(s).
COLLECTIONS=()  # Source collections.

ARGS=()         # Other arguments passed to dspace_delete_bg.
IN_ARGS=''      # When true remaining options are for dspace_delete_bg.

readonly NL='
'

# =============================================================================
# Functions
# =============================================================================

function add_name() # handle_or_mapfile_or_collection
{
    local VALUE="$1"
    blank "$VALUE" && return
    for PART in "`echo "$VALUE" | sed -E 's/[;|\n]+/\n/g'`"; do
        [[ "$PART" ]] && NAMES+=("$PART")
    done
}

function add_handle() # handle_or_list_file
{
    local VALUE="$1"
    blank "$VALUE" && return
    if [[ -e "$VALUE" ]] ; then
        HANDLES+=(`cat "$VALUE"`)
    else
        for PART in `echo "$VALUE" | sed -E 's/[;|\n]+/\n/g'`; do
            [[ "$PART" ]] && HANDLES+=("$PART")
        done
    fi
}

function add_mapfile() # file
{
    local VALUE="$1"
    blank "$VALUE" && return
    for PART in `echo "$VALUE" | sed -E 's/[;|\n]+/\n/g'`; do
        [[ "$PART" ]] && MAP_FILES+=("$PART")
    done
}

function add_collection() # name_or_handle_or_list_file
{
    local VALUE="$1"
    blank "$VALUE" && return
    local ORIGINAL_IFS="$IFS"
    IFS="$NL"
    if [[ -e "$VALUE" ]] ; then
        COLLECTIONS+=(`cat "$VALUE"`)
    else
        for PART in `echo "$VALUE" | sed -E 's/[;|\n]+/\n/g'`; do
            [[ "$PART" ]] && COLLECTIONS+=("$PART")
        done
    fi
    IFS="$ORIGINAL_IFS"
}

# =============================================================================
# Process command line arguments.
# =============================================================================

while [[ $# -gt 0 ]] ; do
    case "$1" in
        --foreground)     NOHUP='' ;;
        --help|-h)        HELP=true ;;
        --all)            ALL=true ;;
        --handle=*)       add_handle "`flag_arg "$1"`" ;;
        --handle)         add_handle "`flag_arg "$1" "$2"`"; shift ;;
        --mapfile=*)      add_mapfile "`flag_arg "$1"`" ;;
        --mapfile|-m)     add_mapfile "`flag_arg "$1" "$2"`"; shift ;;
        --collection=*)   add_collection "`flag_arg "$1"`" ;;
        --collection|-c)  add_collection "`flag_arg "$1" "$2"`"; shift ;;
        -*)               ARGS+=("$1"); IN_ARGS=true ;;
        *)                [[ "$IN_ARGS" ]] && ARGS+=("$1") || add_name "$1" ;;
    esac
    shift
done

# =============================================================================
# Early exit for "--help".
# =============================================================================

if [[ "$HELP" ]] ; then
    echo "Usage: $PROGNAME [DEPLOYMENT] [OPTIONS] ITEMS..."
    echo "Usage: $PROGNAME [DEPLOYMENT] --all"
    cat <<'EOF'
    DEPLOYMENT:
    --production    Delete from the production DSpace service.
    --staging       Delete from the staging DSpace service.

    OPTIONS:
    --all           All items from collections in data/collection.txt
    --handle        Next is a handle or list of handles.
    --mapfile       Next is a mapfile or newline-delimited list of mapfiles.
    --collection    Next is a collection or list of collections.
    --foreground    Do not run in the background with "nohup".
EOF
    exit 0
fi

# =============================================================================
# Finish gathering specifiers of items to delete.
# =============================================================================

# Get "--all" collections from the data file.
if [[ "$ALL" ]] ; then
    COLL_LINES="$PRJ_DIR/data/collection.txt"
    COLL_NAMES=`data_lines "$COLL_LINES" | data_column 2`
    add_collection "$COLL_NAMES"
fi

# Analyze direct arguments into handles, mapfiles, and collections.
for NAME in "${NAMES[@]}"; do
    if [[ "$NAME" =~ item/[0-9]+ ]] ; then
        add_handle "$NAME"
    elif [[ -e "$NAME" ]] ; then
        add_mapfile "$NAME"
    elif [[ "$NAME" ]] ; then
        add_collection "$NAME"
    fi
done

# Ensure items to delete were specified in some manner.
declare -i H_COUNT=${#HANDLES[@]}
declare -i M_COUNT=${#MAP_FILES[@]}
declare -i C_COUNT=${#COLLECTIONS[@]}
[[ `expr $H_COUNT + $M_COUNT + $C_COUNT` -eq 0 ]] && abort 'no items specified'

# =============================================================================
# Ensure pre-conditions are met.
# =============================================================================

dspace_prep

# =============================================================================
# Build a mapfile of the handles to delete and copy it to the DSpace host.
# =============================================================================

TMP_MAP="$PROGNAME.$$.map"
TMP_SRC="$PROGNAME.$$.txt"
trap "rm -f '$TMP_SRC' '$TMP_MAP'" EXIT
> "$TMP_SRC"

# Extract handle from each item.
for HANDLE in "${HANDLES[@]}" ; do
    echo "$HANDLE" | sed -E 's/^.*(item\/[0-9]+).*$/\1/' >> "$TMP_SRC"
done

# Extract handles from each line of each file.
for FILE in "${MAP_FILES[@]}" ; do
    cat "$FILE" | sed -E 's/^.*(item\/[0-9]+).*$/\1/' >> "$TMP_SRC"
done

# Get item handles from each collection.
if [[ $C_COUNT -gt 0 ]] ; then
    announce "Listing items from $C_COUNT collections"
    for COLLECTION in "${COLLECTIONS[@]}" ; do
        echo "Listing items from collection '${COLLECTION}'"
        dspace_item --handle --scope "$COLLECTION" >> "$TMP_SRC"
    done
    echo 'NOTE: collection will be emptied but not removed'
fi

# Construct a mapfile where each line is a unique identifier followed by an
# item handle.
declare -i COUNT
for HANDLE in `sort -u "$TMP_SRC"` ; do
    ((COUNT++))
    echo "$COUNT $HANDLE"
done > "$TMP_MAP"

MAP_NAME=`basename "$TMP_MAP"`
announce "Copying $MAP_NAME for remote dspace_delete_bg command"
dspace_cp "$TMP_MAP" :"$DSPACE_IMPORT_DIR" || exit $?

# =============================================================================
# Invoke DSpace import on the remote system.
# =============================================================================

COMMAND="bin/dspace_delete_bg '$MAP_NAME' ${ARGS[@]}"

if [[ "$NOHUP" ]] ; then
    DATE=`date -I`
    IMPORT_LOG="$DATE-$PROGNAME.txt"
    nohup dspace_sh "$COMMAND" > "$IMPORT_LOG" 2>&1 &
    IMPORT_PID=$!
    announce "Running dspace_delete_bg on $DSPACE_PUBLIC"
    echo "PID: $IMPORT_PID"
    echo "LOG: $IMPORT_LOG"
    if [[ "$WAIT" ]] ; then
        echo
        tail -f "$IMPORT_LOG" &
        TAIL_PID=$!
        wait $IMPORT_PID
        kill $TAIL_PID
    fi
    exit 0
else
    dspace_sh "$COMMAND --foreground"
fi
