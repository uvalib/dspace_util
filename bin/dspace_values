#! /bin/bash
#
# Script values -- intended to be "sourced" not run.

ERROR_STATUS=100

# Ensure that dspace_util scripts are available.
[[ "$PROGRAM"  ]] || PROGRAM=`realpath "$0"`
[[ "$BIN_DIR"  ]] || BIN_DIR=`dirname "$PROGRAM"`
[[ "$PROGNAME" ]] || PROGNAME=`basename "$PROGRAM"`

[[ ":$PATH:" = *":$BIN_DIR:"* ]] || PATH="$BIN_DIR:$PATH"

# Include local overrides and/or other environment variable exports.
LOCAL_VALUES="$BIN_DIR/.values"
[[ -f "$LOCAL_VALUES" ]] && source "$LOCAL_VALUES"

# Extract the script argument indicating which deployment to interact with.
# This is the option indicated by [DEPLOYMENT] in script comments.
SCRIPT_ARGS=()
for ARG in "$@" ; do
    case "$ARG" in
        --deployment=p*|--prod*) export DSPACE_DEPLOYMENT='production' ;;
        --deployment=s*|--stag*) export DSPACE_DEPLOYMENT='staging' ;;
        *)                       SCRIPT_ARGS+=("$ARG") ;;
    esac
done
set -- "${SCRIPT_ARGS[@]}"

# DSpace system properties.
[[ "$DSPACE_DEPLOYMENT" ]] || export DSPACE_DEPLOYMENT='production'
[[ "$DSPACE_PRIVATE"    ]] || export DSPACE_PRIVATE="dspace-$DSPACE_DEPLOYMENT-private.internal.lib.virginia.edu"
[[ "$DSPACE_PUBLIC"     ]] || export DSPACE_PUBLIC="dspace-$DSPACE_DEPLOYMENT.library.virginia.edu"
[[ "$DSPACE_PREFIX"     ]] || export DSPACE_PREFIX='item'

# Names of "UVA Open Community" destination collections.
[[ "$PUB_COLLECTION"  ]] || export PUB_COLLECTION='~ GENERAL, Outside UVA'
[[ "$USR_COLLECTION"  ]] || export USR_COLLECTION='Profiles'
[[ "$ORG_COLLECTION"  ]] || export ORG_COLLECTION='OrgUnits'

# Default locations for import/export.
[[ "$COMMON_ROOT" ]] || export COMMON_ROOT="$HOME/libra-dspace"
[[ "$EXPORT_DIR"  ]] || export EXPORT_DIR='libra-export'
[[ "$IMPORT_DIR"  ]] || export IMPORT_DIR='dspace-import'

# =============================================================================
# Functions
# =============================================================================

function announce() # output_lines...
{
    for MSG in "$@" ; do
        echo
        echo -n '***' "$MSG"
    done
    echo ' ...'
}

function abort() # output_lines...
{
    for MSG in "$@" ; do
        echo "$PROGNAME: $MSG" 1>&2
    done
    exit $ERROR_STATUS
}

function strip()
{
    sed -E -e 's/^[ \t]+//' -e 's/[ \t]+$//'
}

function blank() # value
{
    [[ "$1" =~ ^' '*$ ]]
}

function flag_arg() # --flag=value | --flag value
{
    local FLAG="$1"                         # "--flag=value" or "--flag value".
    local VALUE="${FLAG#*=}"                # Check for "--flag=value".
    [[ "$VALUE" = "$FLAG" ]] && VALUE="$2"  # Default to "flag value".
    blank "$VALUE" && abort "missing $FLAG argument"
    echo "$VALUE"
}
