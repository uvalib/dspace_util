#! /bin/bash
#
# Import items into DSpace within a DSpace login shell.
#
# Usage: dspace_import ZIP_FILE [OPTIONS] [DSPACE_OPTIONS]
# Usage: dspace_import --help
#
# The first argument to the script is the zip file, then local script options,
# then the remainder are `dspace import` command line arguments although
# certain combinations are untested.
#
# OPTIONS
#   --nohup             Background the import process.
#   --wait              Wait for background import process to finish.
#
# For reference, `dspace import` command line arguments are:
#
# Argument              Description                                 Notes
# Short Long
# ----- ------------    ----------------------------------------    -----------------------
# -a    --add           Add items to DSpace                         Can't use with -r or -d
# -r    --replace       Replace items listed in mapfile             Can't use with -a or -d
# -d    --delete        Delete items listed in mapfile              Can't use with -a or -r
# -s    --source        Source directory of zipfile
# -c    --collection    Destination Collection                      By Handle or database ID
# -m    --mapfile       Mapfile for items                           Will be created by --add
# -e    --eperson       DSpace account doing the import
# -w    --workflow      Send through the Collection's workflow
# -n    --notify        Kicks off email reporting imported items
# -v    --validate      Test run; do not actually import items
# -p    --template      Apply the Collection template
# -R    --resume        Resume a failed import                      For --add only
# -h    --help          Command help
# -z    --zip           Zipfile
# -q    --quiet         Don't display metadata                      Not on documentation page.
# -u    --url           URL of zip file.                            Not on documentation page.
# -x,   --exclude-bitstreams    Do not load content bitstreams      Not on documentation page.
#
# @see https://wiki.lyrasis.org/display/DSDOC8x/Importing+and+Exporting+Items+via+Simple+Archive+Format

# NOTE: Review bin/dspace_collection for proper target Collections.

PROGRAM=`realpath "$0"`
BIN_DIR=`dirname "$PROGRAM"`

source "$BIN_DIR/dspace_values"

NOHUP=''        # Background the import process.
WAIT=''         # Wait for background import process to finish.
HELP=''         # Display help only.
KEEP_MAP=''     # Do not backup existing mapfile.

MAP_FILE=''     # Name of output mapfile.
ZIP_FILE=''     # Name of input zip file.
ZIP_PATH=''     # Path to input zip file.
SRC_DIR=''      # Directory of input zip file.
EPERSON=''      # DSpace account of submitter.
COLLECTION=''   # Expect items to have a "collections" file.

ARGS=()         # Other arguments passed to `dspace import`.

# =============================================================================
# Functions
# =============================================================================

function set_zip() # path_name
{
    local VALUE="$1"
    [[ "$VALUE" ]] || return
    [[ "$ZIP_PATH" == "$VALUE" ]] && return
    [[ "$ZIP_PATH" ]] && abort "zipfile path already set to '$ZIP_PATH'"
    ZIP_PATH="$VALUE"
}

# =============================================================================
# Process command line arguments.
# =============================================================================

while [[ $# -gt 0 ]] ; do
    case "$1" in
        --nohup)            NOHUP=true ;;
        --wait)             WAIT=true ;;
        --add|-a)           ;; # No-op: this script only handles "add".
        --delete|-d)        abort "this script does not implement 'delete'" ;;
        --replace|-r)       abort "this script does not implement 'replace'" ;;
        --collection=*)     COLLECTION=`flag_arg "$1"` ;;
        --collection|-c)    COLLECTION=`flag_arg "$1" "$2"`; shift ;;
        --eperson=*)        EPERSON=`flag_arg "$1"` ;;
        --eperson|-e)       EPERSON=`flag_arg "$1" "$2"`; shift ;;
        --mapfile=*)        MAP_FILE=`flag_arg "$1"` ;;
        --mapfile|-m)       MAP_FILE=`flag_arg "$1" "$2"`; shift ;;
        --source=*)         SRC_DIR=`flag_arg "$1"` ;;
        --source|-s)        SRC_DIR=`flag_arg "$1" "$2"`; shift ;;
        --zip=*)            set_zip `flag_arg "$1"` ;;
        --zip|-z)           set_zip `flag_arg "$1" "$2"`; shift ;;
        --help|-h)          HELP=true; KEEP_MAP=true ;;
        --resume|-R)        ARGS+=("$1"); KEEP_MAP=true ;;
        --validate|-v)      ARGS+=("$1"); KEEP_MAP=true ;;
        --url=*)            ARGS+=("$1") ;;
        --url)              ARGS+=("$1=$2"); shift ;;
        -u)                 ARGS+=("$1" "$2"); shift ;;
        -*)                 ARGS+=("$1") ;;
        *)                  set_zip "$1" ;;
    esac
    shift
done

# =============================================================================
# Early exit for "--help".
# =============================================================================

if [[ "$HELP" ]] ; then
    echo "Usage: $PROGNAME ZIP_FILE [OPTIONS] [DSPACE_OPTIONS]"
    cat <<'EOF'
    OPTIONS:
    --nohup     Background the import process.
    --wait      Wait for background import process to finish.

    DSPACE IMPORT OPTIONS:
EOF
    dspace import --help | sed '/^usage.*$/d'
    exit 0
fi

# =============================================================================
# Ensure pre-conditions are met.
# =============================================================================

# The zip file should be first argument to script; other flags like '-v' may
# come after it.
[[ "$ZIP_PATH" ]] || abort 'relative path to zip file not given'
[[ "$SRC_DIR"  ]] || SRC_DIR=`dirname "$ZIP_PATH"`
[[ "$ZIP_FILE" ]] || ZIP_FILE=`basename "$ZIP_PATH"`
[[ "$MAP_FILE" ]] || MAP_FILE=`basename "$ZIP_FILE" .zip`.map

# Make sure the submitter is in the form of a DSpace user name.
EPERSON=`dspace_account "$EPERSON"`

# Make a relative source directory path absolute.
[[ "$SRC_DIR" ]] || SRC_DIR="$IMPORT_PATH"
case "$SRC_DIR" in
    "$IMPORT_PATH"|"$HOST_IMPORT_PATH") ;; # OK
    "$DSPACE_IMPORT_PATH")              SRC_DIR="$HOST_IMPORT_PATH" ;;
    *)                                  SRC_DIR=`realpath "$SRC_DIR"` ;;
esac

# Move into the zip directory, which should be writable by user "dspace".
cd "$SRC_DIR" || exit $?

# If there is an existing mapfile, move it out of the way unless attempting to
# resume a failed import.
if [[ -z "$KEEP_MAP" && -e "$MAP_FILE" ]] ; then
    mv "$MAP_FILE" "$MAP_FILE".`date +'%T.%N'` || exit $?
fi

# If DSpace runs in a Docker container, zip files must be in the directory
# which is mounted within the Docker container at $DSPACE_IMPORT_PATH, and
# $MAP_FILE must be absolute (otherwise it would be deposited at the root of
# the container's file system).
if [[ "$DSPACE_DOCKER" ]] ; then
    case "$SRC_DIR" in
        "$IMPORT_PATH"|"$HOST_IMPORT_PATH") SRC_DIR="$DSPACE_IMPORT_PATH" ;;
        "$DSPACE_IMPORT_PATH") ;; # OK
        *) abort "$SRC_DIR not mapped to $DSPACE_IMPORT_PATH" ;;
    esac
    SRC_DIR="$DSPACE_IMPORT_PATH"
    MAP_FILE="$SRC_DIR/$MAP_FILE"
fi

# =============================================================================
# Run import command which will generate $MAP_FILE with item subdirectories
# mapped to the handles of the DSpace items generated from them.
# =============================================================================

[[ "$COLLECTION" ]] && ARGS+=(-c "$COLLECTION")
[[ "$EPERSON"    ]] && ARGS+=(-e "$EPERSON")
[[ "$MAP_FILE"   ]] && ARGS+=(-m "$MAP_FILE")
[[ "$SRC_DIR"    ]] && ARGS+=(-s "$SRC_DIR")
[[ "$ZIP_FILE"   ]] && ARGS+=(-z "$ZIP_FILE")

COMMAND="dspace import --add ${ARGS[@]}"

if [[ "$NOHUP" ]] ; then
    DATE=`date -I`
    NAME=`basename "$ZIP_FILE"`
    IMPORT_LOG="$DATE-$NAME.txt"
    nohup bash -c "$COMMAND" > "$IMPORT_LOG" 2>&1 &
    IMPORT_PID=$!
    echo "REMOTE $PROGNAME running $COMMAND"
    echo "REMOTE $PROGNAME PID: $IMPORT_PID"
    echo "REMOTE $PROGNAME LOG: $IMPORT_LOG"
    if [[ "$WAIT" ]] ; then
        echo
        tail -f "$IMPORT_LOG" &
        TAIL_PID=$!
        wait $IMPORT_PID
        kill $TAIL_PID
    fi
    exit 0
else
    eval "$COMMAND"
fi
